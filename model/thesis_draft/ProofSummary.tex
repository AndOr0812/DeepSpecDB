% Use this template to write your solutions to COS 423 problem sets

\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsfonts, amsthm, amssymb, algorithm, graphicx, mathtools,xfrac}
\usepackage[noend]{algpseudocode}
\usepackage{fancyhdr, lastpage}
\usepackage[vmargin=1.20in,hmargin=1.25in,centering,letterpaper]{geometry}
\setlength{\headsep}{.50in}
\setlength{\headheight}{15pt}

% Landau notation
\DeclareMathOperator{\BigOm}{\mathcal{O}}
\newcommand{\BigO}[1]{\BigOm\left({#1}\right)}
\DeclareMathOperator{\BigTm}{\Theta}
\newcommand{\BigTheta}[1]{\BigTm\left({#1}\right)}
\DeclareMathOperator{\BigWm}{\Omega}
\newcommand{\BigOmega}[1]{\BigWm\left({#1}\right)}
\DeclareMathOperator{\LittleOm}{\mathrm{o}}
\newcommand{\LittleOh}[1]{\LittleOm\left({#1}\right)}
\DeclareMathOperator{\LittleWm}{\omega}
\newcommand{\LittleOmega}[1]{\LittleWm\left({#1}\right)}

% argmin and argmax
\newcommand{\argmin}{\operatornamewithlimits{argmin}}
\newcommand{\argmax}{\operatornamewithlimits{argmax}}

\newcommand{\calP}{\mathcal{P}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Exp}{\mathbb{E}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\sign}{\mathrm{sign\ }}
\newcommand{\abs}{\mathrm{abs\ }}
\newcommand{\eps}{\varepsilon}
\newcommand{\zo}{\{0, 1\}}
\newcommand{\SAT}{\mathit{SAT}}
\renewcommand{\P}{\mathbf{P}}
\newcommand{\NP}{\mathbf{NP}}
\newcommand{\coNP}{\co{NP}}
\newcommand{\co}[1]{\mathbf{co#1}}
\renewcommand{\Pr}{\mathop{\mathrm{Pr}}}

% theorems, lemmas, invariants, etc.
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{invariant}[theorem]{Invariant}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{property}[theorem]{Property}
\newtheorem{proposition}[theorem]{Proposition}

% piecewise functions
\newenvironment{piecewise}{\left\{\begin{array}{l@{,\ }l}}
{\end{array}\right.}

% paired delimiters
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\len}{|}{|}
\DeclarePairedDelimiter{\set}{\{}{\}}

\makeatletter
\@addtoreset{equation}{section}
\makeatother
\renewcommand{\theequation}{\arabic{section}.\arabic{equation}}

% algorithms
\algnewcommand\algorithmicinput{\textbf{INPUT:}}
\algnewcommand\INPUT{\item[\algorithmicinput]}
\algnewcommand\algorithmicoutput{\textbf{OUTPUT:}}
\algnewcommand\OUTPUT{\item[\algorithmicoutput]}


% Formating Macros

\pagestyle{fancy}
\lhead{\sc \hmwkClass $\;\;\cdot \;\;$ \hmwkSemester $\;\;\cdot\;\;$
Proof Summary}
%\chead{\sc Problem \hmwkAssignmentNum.\hmwkProblemNum}
%\chead{}
\rhead{\em \hmwkAuthorName\ $($\hmwkAuthorID$)$}
\cfoot{}
\lfoot{}
\rfoot{\sc Page\ \thepage\ of\ \protect\pageref{LastPage}}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\fancypagestyle{problemstatement}
{
    \rhead{}
    \lfoot{}
}

%%%%%% Begin document with header and title %%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%% Header Information %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Shouldn't need to change these
\newcommand{\hmwkClass}{Thesis}
\newcommand{\hmwkSemester}{Spring 2018}

%%% Your name, in standard First Last format
\newcommand{\hmwkAuthorName}{Brian McSwiggen}
%%% Your NetID
\newcommand{\hmwkAuthorID}{bm14}

%%%%%%% begin Summary %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This document aims to give a brief and informal summary of the relevant lemmas and theorems for my thesis. Each section describes at a high level the goals of the relevant portion of the implementation, describes the important lemmas and theorems, and lists the associated Coq theorem names. Formatting issues have made it difficult to include the formal statement of each theorem, but they can all be found in BTrees.v.

\section{Element List Abstraction}

We represent a cursor abstractly as a pair of key-value lists. The first is the "left" list, of all the key-value pairs with keys \textit{less} than the cursor's current position; the second is the "right" list with the pairs \textit{greater} than the current position.

Both lists are ordered by distance to the cursor's position, i.e. the adjacent key-value pair to each side is the first element of the corresponding list. The first element of the tree is the last element of the "left" list. The last element of the tree is the last element of the "right" list.

We can translate a cursor into this paired-list using \texttt{cursor\_elements}; we can also translate a cursor into just the left or right lists using \texttt{cursor\_left} or \texttt{cursor\_right}, respectively.

\bigskip
\texttt{cursor\_elements'\_sides\_equiv}

\begin{lemma}
The pair produced by \texttt{cursor\_elements} is equal to the pair of \texttt{cursor\_left} and \texttt{cursor\_right}.
\end{lemma}

\begin{proof}
This has been formally proved in Coq.
\end{proof}

Both the right and left functions are called recursively and gradually build up a "base" of elements already added. For both directions, we process elements from inside outward. Therefore, we want to prove the following:

\bigskip
\texttt{right\_el\_interior} and \texttt{left\_el\_interior}

\texttt{left\_rec\_interior} and \texttt{right\_rec\_interior}

\begin{lemma}
For both the left and right functions, the "base" they are passed ends up at the beginning of the list, i.e. if the base is \texttt{b} and the end result is \texttt{l}, then there is some \texttt{l'} such that \texttt{l = b++l'}.
\end{lemma}

\begin{proof}
This has been formally proved in Coq.
\end{proof}

We also want to show that cursors are processed from the bottom up, and that the things reached from the bottom (which are consequently closer to the cursor position) end up in the base first. In other words, we want to prove the following:

\bigskip
\texttt{cursor\_right\_elements1} and \texttt{cursor\_left\_elements1}

\begin{lemma}
For both the left and right functions, if we split a cursor into two parts, then the result of computing the elements of the whole cursor is equal to the result of first computing the elements of the first part, then using that as the base for computing the elements of the second part.
\end{lemma}

\begin{proof}
This has been formally proved in Coq.
\end{proof}

Finally, we need to prove that the element list actually represents the tree:

\bigskip
\texttt{cursor\_right\_el\_sorted} and \texttt{cursor\_left\_el\_sorted}

\begin{theorem}
The element list for a correct cursor (i.e. of an in-order tree) is in order.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been proved.
\end{proof}

\section{Abstract Cursor Position}

This abstract element-list works well for what a cursor should represent, but it has a problem for the actual structure of a cursor: two \textit{structurally} different cursors could be \textit{abstractly} the same! Consider one cursor pointing at the very end of a leaf, and another cursor pointing at the very beginning of the next leaf.

So, we need a way to work with these cursors. Specifically, we create \texttt{next\_node} and \texttt{prev\_node}, which ensure a cursor either has an element immediately to its right or has an element immediately to its left. If a cursor is already in an acceptable position, then it should not be changed.

Importantly, these functions should not alter the abstract element-list representation of the cursor. In order to prove this, we have to first prove an invariant of the recursive right and left functions:

\bigskip
\texttt{cursor\_right\_elements4}, uses \texttt{point\_next}

\begin{invariant}
Let $c$ be a correct (partial) cursor, and let $c'$ be the (partial) cursor returned by \texttt{next\_cursor} of $c$. Then if $l$ is the right portion of the element list for $c$, and $l'$ is the right portion of the element list for $c'$, then the two lists are the same, except for the subtree pointed to by $c'$ if the cursor is pointing to an internal node.
\end{invariant}

\begin{proof}
This has been \textbf{mostly} proved in Coq. The exceptions are a couple of admits that follow directly from the cursor being correct.
\end{proof}

\bigskip
\texttt{cursor\_left\_elements4}, uses \texttt{left\_el\_app}

\begin{invariant}
Let $c$ be a correct (partial) cursor, and let $c'$ be the (partial) cursor returned by \texttt{next\_cursor} of $c$. Then if $l$ is the left portion of the element list for $c$, and $l'$ is the left portion of the element list for $c'$, then the two lists are the same, except for the subtree pointed to by $c$ if the cursor is pointing to an internal node.
\end{invariant}

\begin{proof}
This has been \textbf{partially} proved in Coq.
\end{proof}

We need to ensure that if \texttt{next\_cursor} is called on any correct cursor, then the result is also correct.

\bigskip
\texttt{next\_correct\_struct} and \texttt{next\_node\_balanced}

\texttt{next\_node\_sorted} and \texttt{next\_node\_fanout}

\texttt{next\_node\_correct}

\begin{lemma}
\texttt{next\_cursor} preserves cursor correctness.
\end{lemma}

\begin{proof}
This has been \textbf{partially} proved in Coq.
\end{proof}

We also need to prove all of these properties for \texttt{prev\_cursor}; this has not yet been formally done in Coq.

We can now apply these invariants to \texttt{cursor\_elements} as a whole:

\bigskip
\texttt{cursor\_elements\_next and cursor\_elements\_prev}

\begin{theorem}
If $c$ is a correct cursor, then \texttt{next\_cursor} of $c$, \texttt{prev\_cursor} of $c$, and $c$ all have the same element-list representation.
\end{theorem}

\begin{proof}
This follows directly from the invariants stated above, but has not yet been formally proved in Coq because those proofs have not been completed.
\end{proof}

\section{Cursor Creation}

In order to create a cursor, we recursively build up a list of indices into treelists, starting from the root and going down to the leaf that contains (or would contain) the key the cursor is pointing at. We need to prove primarily two things: first, that this produces a correct cursor; and second, that the positioning of the cursor (relative to the abstract element-list representation) is correct.

\bigskip
\texttt{make\_cursor\_rec\_correct} and \texttt{make\_cursor\_correct}

\begin{theorem}
\texttt{make\_cursor} produces a structurally correct cursor.
\end{theorem}

\begin{proof}
This has been \textbf{partially} proved in Coq.
\end{proof}

\bigskip
\texttt{make\_cursor\_right} and \texttt{make\_cursor\_left}

\begin{theorem}
The cursor $c$ returned by \texttt{make\_cursor} for a given key $k$ has the property that the immediate right element has key greater than or equal to $k$, and the immediate left element has key less than $k$.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been proved.
\end{proof}

\section{Cursor Movement}

For \texttt{move\_to\_next} and \texttt{move\_to\_prev}, we similarly need to prove structural correctness and correctness relative to the element list abstraction.

\bigskip
\texttt{move\_to\_next\_correct} and \texttt{move\_to\_prev\_correct}

\begin{theorem}
Both functions, given a correct cursor, produce a correct cursor.
\end{theorem}

\begin{proof}
This has been formally proved for \texttt{move\_to\_next}, but not for \texttt{move\_to\_prev}. The proof would follow the same structure, and will be easy.
\end{proof}

\bigskip
\texttt{move\_to\_next\_el}

\begin{theorem}
If $c$ has the element lists $(l,(k,v)::r)$, then next of $c$ has element lists $((k,v)::l,r)$.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been proved.
\end{proof}

\bigskip
\texttt{move\_to\_prev\_el}

\begin{theorem}
If $c$ has the element lists $((k,v)::l,r)$, then prev of $c$ has element lists $(l,(k,v)::r)$.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been proved.
\end{proof}

\bigskip
\texttt{move\_to\_next\_none} and \texttt{move\_to\_prev\_none}

\begin{theorem}
If $c$ has no element to its right (or to its left), then next of $c$ (or prev of $c$) is just $c$.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been proved.
\end{proof}

\section{Get}

Now that we've set up the element-list abstraction, there's actually only one thing that we need to prove about \texttt{get}. Furthermore, the proof follows immediately from what we've already proven!

\bigskip
\texttt{get\_correct}

\begin{theorem}
\texttt{get} returns the key-value pair at the front of the right list in the element-list abstraction.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been formally proved.

However, the proof will mirror the following intuitive proof:

We know that \texttt{next\_node} positions the cursor structurally right next to a key-value pair without changing the element-list representation. Then \texttt{get} returns that element directly to the right, which must also be the front of the right element-list.
\end{proof}

\section{Insert}

Insertion has three distinct cases to consider when inserting a key-value pair $(k,v)$:
\begin{enumerate}
    \item If the cursor is not correctly positioned for $k$, then it should return the cursor unchanged.
    \item If the cursor is correctly positioned, but $k$ is not in the tree, then it should add the new pair $(k,v)$.
    \item If the cursor is correctly positioned, and $k$ is in the tree (meaning it is the next key to the right in the element list), then it should replace the value for $k$ with $v$.
\end{enumerate}

We can prove a helpful lemma with regards to the first point:

\bigskip
\texttt{bad\_cursor\_insert\_same}

\begin{lemma}
If the key $k$ is not in the range of keys represented by this cursor, then \texttt{insert} returns back the original cursor.
\end{lemma}

\begin{proof}
This has \textbf{not} yet been proved.
\end{proof}

Now consider insertion of a key $k$ into a cursor that represents $k$. We first want to prove that insert is structurally correct, i.e. a correct cursor, once inserted into, gives back a correct cursor.

\bigskip
\texttt{insert\_correct}

\begin{theorem}
If $c$ is a cursor into a correct b+tree (balanced, fanout, and ordered), then for any key $k$ and value $v$, inserting $(k,v)$ into $c$ produces a cursor into a correct b+tree.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been proved. In Coq, it would be most likely split into three separate proofs (one for each correctness property), for simplicity and clarity. However, for the statement now we have combined it with \textbf{Theorem 18}.
\end{proof}

\bigskip
\texttt{insert\_correct}

\begin{theorem}
If $c$ is a structurally correct cursor (each level contains the next, and the last level is a leaf node) then for any $k$ and $v$, inserting $(k,v)$ into $c$ produces a structurally correct cursor.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been proved.
\end{proof}

Then, we want to prove what it does to the element-list abstraction, i.e. that it either replaces the next key-value pair or inserts this key-value pair at the cursor's position.

\bigskip
\texttt{insert\_eq\_elements}

\begin{theorem}
If the next key is equal to the key $k$ being inserted, then let $l$ be the left element list and $(k,v')::r$ be the right element list. Then inserting $(k,v)$ into the cursor produces a cursor with element list equal to: $(l,(k,v)::r)$.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been proved.
\end{proof}

\bigskip
\texttt{insert\_neq\_elements}

\begin{theorem}
If the next key is not equal, then let $l$ be the left element list and $r$ be the right element list. Then insertion produces a cursor with element list equal to $((k,v)::l,r)$.
\end{theorem}

\begin{proof}
This has \textbf{not} yet been proved.
\end{proof}

%%%%%%% end Summary %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
